#헤드퍼스트 자바 3판  
다시 공부 하는 자바 
- IDE : vscode
- 자바 : openjdk version "17.0.7"  
-----------이슈 기록-------------
1. 한글이 포함되어 있는 경우 컴파일시 에러나면 다음과 같이 컴파일
```java
javac 파일명.java -encoding utf-8 
```
2. 2장 요약 : 클래스와 객체
- 오버라이드(override) : 상속 받은 메서드를 재정의 하는 것
- 인스턴스 변수 : 객체가 자신에 대해 아는 것(상태)
- 메서드 : 객체가 자신이 하는 것(행동)
- 클래스 : 객체를 만들기 위한 설계도
- 객체 : 고유의  변수, 고유의 기능을 지정할 수 있다.
3. 3장 요약 : 원시 변수와 레퍼런스
- 자바는 타입(type)를 철저하게 따진다.
- 변수는 원시 변수, 객체 레퍼런스로 나뉜다.
- 원시 타입  
    - 불리언과 문자  
    boolean : true 또는 false  
    char 16비트 : 0~65535  
    - 정수  
    byte 8비트 : -128~127  
    short 16비트 : -32768~32767  
    int 32비트 : -2147483648~2147483647  
    long 64비트 : -2의 63승~2의 63승-1  
    - 부동 소수점 수  
    float 32비트   
    double 64비트  
- 객체 레퍼런스
    - 객체 레퍼런세에 객체 자체가 들어가는 것이 아니다.
    - 객체는 변수에 집어 넣을 수 없다.
    - 객체 레퍼런스 변수에는 객체에 접근하는 방법을 나타내는 비트가 들어있다.
    - 점 연산사(.)를 사용하면 객체를 이용해서 메서드를 호출하라는 의미다.
    - 레퍼런스 변수가 아무 객체도 참조하지 않으면 그 값은 null이 된다.
    - 배열은 항상 객체다. 배열에 원시 변수를 저장하도록 선언해도 마찬가지다.
- 객체 선언, 생성과 대입의 3단계  
    Dog myDog = new Dog(); 의 해석  
    (1) 레퍼런스 변수 선언 단계  
    Dog myDog : JVM에 Dog 타입의 레퍼런스 변수용 공간을 할당해달라 요청   
    (2) 객체 생성 단계  
    new Dog(); : JVM에 힙에 새로운 Dog 객체를 위한 공간을 마련하도록 지시  
    (3) 객체와 레퍼런스 연결 단계  
    = : 새로운 Dog 객체를 myDog라는 레퍼런스 변수에 대입한다.
4. 4장 요약 : 메서드는 인터턴스 변수를 사용한다.
- 메서드에서 인스턴스 변수를 이용해서 같은 타입의 객체가 다른 식으로 행동하게 할 수 있다.
- 메서드에서 매개변수를 사용할 수 있다. 메서드에 값 한 개 이상을 전달할 수 있다.
- 전달하는 값의 개수와 타입은 반드시 메서드를 선언할 때 지정한 것과 같아야 하며 그 순서도 같아야 한다.
- 메서드 안밖으로 전달되고 리턴되는 값은 상황에 짜라 자동으로 더 큰 타입으로 올라갈 수 있다.
- 더 작은 타입으로 바꿔야 한다면 강제로 캐스팅 해야 한다.
- 메서드를 선언할 때 반드시 리턴 타입을 지정해야 한다. void로 지정하면 리턴하지 않아도 된다.
- 메서드를 선언할 때 void가 아니라 리턴 타입을 지정했을 때는 반드시 선언된 리턴 타입과 호환 가능한 값을 리턴해야 한다.
- 인스턴스 변수는 private 로, getter, setter는 public 로 캡슐화
- 캡슐화를 하면 값을 직접 변경할 수 없어서 데이터 안전
- 다른 코드에서 객체의 데이터를 건드리는 것을 통제하려면 세터처럼 값을 바꾸는 공개 메서드를 만들면 된다.
- 인스턴스 변수에는 명시적으로 값을 설정하지 않아도 기본값이 대입된다.
- 로컬 변수(메서드 안에 있는 변수)는 기본값이 대입되지 않아서 초기화를 해야 한다.
- 두 원시 값이 같은지 확인할 때는 == 연산자를 사용한다.
- 두 레퍼런스가 같은지 확인할 때는 == 연산자를 사용한다.
- 두 객체가 동치인지 확인하고 싶으면 .equals()를 사용한다.
5. 5장 요약 : 프로그램 만들기
- 새로운 클래스를 만들 때는 준비 코드, 테스트 코드, 실제(자바) 코드를 만들어야 한다.
- 준비 코드는 무엇을 해야 할지 기술하는 것
- 테스트 코드를 설계할 때는 준비 코드를 활용한다.
- 메서드를 구현하기 전에 테스트 코드를 만든다.
- 반복문 코드 반복 횟수를 미리 알 경우에는 for문을 사용한다.
- 배열이나 컬렉션에 대해서 반복문을 돌릴 때는 향상된 for문을 사용한다.
6. 6장 요약 : 자바 API
- ArrayList는 자바 API에 포함되어 있는 클래스다.
- ArrayList에 무언가를 넣을 때는 add()를 쓰면 된다.
- ArrayList에 무언가를 제거할 때는 remove() 쓰면 된다.
- ArrayList에 들어 있는 어떤 것의 위치나 그것이 들어 있는지 알고 싶으면 indexOf()를 쓰면 된다.
- ArrayList에 비어 있는지 확인 할 때는 isEmpty()를 쓰면 된다.
- ArrayList의 크기(원소의 개수)를 알고 싶을 때는 size()를 쓰면 된다.
- 일반 배열의 길이(원소의 개수)를 알고 싶을 때는 length라는 변수를 쓰면 된다.
- ArrayList는 필요에 따라 그 크기가 자동으로 바뀝니다. 객체를 추가하면 커지고 제거하면 작아진다.
- ArrayList에 저장할 객체 타입은 타입 이름을 <>안에 집어넣는 형태의 타입 매개변수로 선언한다.
- ArrayList에는 원시타입의 값은 저장할 수 없고 일반  객체만 저장할 수 있다.
- 클래스는 패키지 단위로 묶는다.
- 클래스에는 패키지명과 클래스명을 합쳐서 만든 전체 이름이 있다.
- java.lang를 제외한 다른 패키지에 들어 있는 클래스를 사용하려면 자바 클래스의 전체 이름을 알려줘야 한다.
- 소스 코드 파일 맨 위에서 import 명령문을 사용한다
7. 7강 요약 : 상속과 다형성
- 하위 클래스는 상위 클래스를 확장한다.
- 하위 클래스는 상위 클래스에 있는 모든 public으로 지정한 인스턴스 변수와 메서드를 상속한다.
- private로 지정한 인스턴스 변수와 메서드는 상속하지 않는다.
- 상속된 메서드는 오버라이드할 수 있지만, 인스턴스 변수는 오버라이드 할 수 없다.
- 'A는 B다' 테스트를 활용해서 상속 계층이 올바른지 확인한다. x가 y를 확장한 것이라면 'x는 y다'라고 할 수 있어야 한다.
- 'A는 B다' 관계는 한 방향으로만 작동한다. 하마는 동물이지만, 모든 동물이 하나는 아니다.
- 하위 클래스에서 메서드를 오버라이드 했을 때, 하위 클래스의 인스턴스에 대해 그 메서드를 호출하면 오버라이드된 버전의 메서드가 호출된다.
- 오버라이드 : 상속한 메서드를 재정의 하는 것.
    - 인자는 같아야 하고, 리턴 타입은 호환이 가능해야한다.
    - 메서드를 접근 단계를 어렵게 만들면 안된다.
- 메서드 오버로딩 : 이름은 같지만 인자 목록이 다른 메서드 2개를 만드는 것
    - 리턴 타입이 달라도 된다.
    - 리턴 타입만 바꿀 수는 없다.
    - 접근 단계를 마음대로 바꿀 수 있다.
    - 오버로딩된 메서드는 메서드 이름만 같을 뿐 서로 다른 메서드다.
    - 상속이나 다형성하고는 전혀 관계가 없다.
    - 오버로딩과 오버라이딩은 서로 다른 개념이다.
8. 8강 요약 : 인터페이스와 추상 클래스
- 클래스를 만들 때 인스턴스를 만들 수 없게 하려면 abstract 키워드를 사용한다.
- 추상 클래스에는 추상 메서드와 추상 메서드가 아닌 메서드를 모두 넣을 수 있다.
- 클래스에는 추상 메서드가 하나라도 있으면 그 클래스는 추상 클래스로 지정해야 한다.
- 추상 메서드에는 본체가 없으며, 선언 부분은 세미콜론으로 끝난다.
- 상속 트리에서 처음으로 나오는 구상 클래스에서는 반드시 모든 추상 메서드를 구현해야 한다.
- 자바에 들어 있는 모든 클래스는 직접 또는 간접적으로 Object의 하위 클래스다.
- 메서드를 선언할 때 인자, 리턴 타입을 Object로 지정해도 된다.
- 어떤 객체에 대하여 메서드를 호출하려면 그 객체를 참조하는 레퍼런스 변수 타입의 클래스에 그 메서드가 있어야 한다.
- 메서드가 호출되면 그 메서드의 객체 타입의 구현을 사용한다.
- 죽음의 다이아몬드 문제 때문에 자바는 다중 상속을 허용하지 않는다. 클래스는 단 하나만 상속(확장) 할 수 있다.
- 인터페이스를 만들 때는 interface 키워드를 사용한다.
- 인터페이스를 구현할 때는 implements 키워드를 사용한다.
- 클래스를 만들 때 인터페이스를 여러개 구현할 수 있다.
- 기본 메서드, 정적 메서드를 제외하면 인터페이스를 구현하는 클래스는 그 인터페이스에 있는 모든 메서드를 구현해야 한다.
- 하위 클래스에서 오버라이드 했는데, 상위 클래스 버전을 호출하고 싶다면 super 키워드를 사용하면 된다.
9. 9강 요약 : 생성자와 가비지 컬렉션
- 인스턴스 변수는 그 변수가 들어 있는 객체 안에(힙 안에) 저장된다.
- 인스턴스 변수가 객체에 대한 레퍼런스인 경우에는 레퍼런스와 객체가 모두 힙에 저장된다.
- new 키워드를 사용할 때 실행되는 코드를 생성자라고 한다.
- 생성자명은 반드시 클래스명과 같아야 하며, 리턴 타입은 없어야 한다.
- 생성자를 이용해서 생성되는 객체의 상태(인스턴스 변수)를 초기화 할 수 있다.
- 클래스에 생성자가 없으면 컴파일러에서 기본 생성자를 만든다.
- 기본 생성자는 언제나 인자가 없는 생성자다.
- 클래스를 만들 때 생성자를 만들면 기본 생성자를 만들어주지 않는다.
- 인자가 없는 생성자를 만들고 싶은데, 인자가 있는 생성자가 따로 있다면 인자가 없는 생성자도 손수 만들어야 한다.
- 생성자 오버로딩을 활용하면 클래스에 두 개 이상의 생성자를 만들 수 있다.
- 오버로드된 생성자들의 인자 목록은 반드시 서로 달라야 한다.
- 인자 목록이 똑같은 생성자가 두 개 이상 있을 수 없다. 인자 목록을 따질 때는 순서와 인자의 타입을 모두 따진다.
- 직접 기본값을 지정하지 않아도 인스턴스 변수에는 자동으로 기본값이 지정된다. 
- 원시 타입의 기본값은 0/0.0/false 고, 객체에 대한 레퍼런스의 기본값은 null 이다. 
10. 10강 요약 : 숫자와 정적 변수, 정적 메서드
- 정적 메서드는 객체 레퍼런스 변수 대신 클래스명을 써서  호출한다.
- 정적 메서드는 힙에 그 메서드가 들어 있는 클래스의 인슽턴스가 없어도 호출할 수 있다.
- 특정 인스턴스 변숫값에 의존하지 않는 유틸리티 메서드는 정적 메서드로 만드는 것이 좋다.
- 정적  메서드에서는  특정 인스턴스와는 연관되지 않았으니 어떤 인스턴스 변수값도 사용할 수 없다.
- 정적 메서드가 아닌 메서드는 보통 인스턴스 변수와 연관되어 있으므로 정적 메서드에서는 정적 메서드가 아닌 메서드를 사용할 수 없다.
- 정적 메서드만 들어 있는 클래스가 있다면 그 클래스의 인스턴스를 만들 필요가 없으므로 그 생성자를 private로 지정하는 것이 좋다.
- 정적 변수는 해당 클래스에 속하는 몯든 객체에서 공유하는 변수
- 정적 메서드에서도 정적 변수를 사용할 수 있다.
- 자바에서 상수를 만들 때는 변수에 staticdhk final로 지정하면 된다.
- final로 지정한 정적 변수는 변수를 선언할 때 또는 정적 초기화 부분에서 반드시 값을 대입해야 한다.
- 상수의 이름은 전부 대문자를 사용하고 각 단어 사이에는 밑줄(_)을 넣어준다.
- final로 지정한 변수값은 한번 대입하면 바꿀 수 없다.
- final 인스턴스 변수값은 선언할 때 또는 생성자에서 대입해야 한다.
- final 메서드는 오버라이드 할 수 없다.
- final 클래스는 확장할 수 없다.(하위 클래스를 만들 수 없다.)
11. 11강 요약 : 자료구조
- java.util.List  
sort(Comparator): 주어진 Comparator에 의해 정해지는 순서에 따라 리스트를 정렬한다.
- java.util.Collections  
sort(List) : 주어린 리스트를 그 리스트에  있는 원소들의 자연스러운 순서(오름차순)를 기준으로 정렬한다.    
sort(List,  Comparator) : 주어진 리스트를 Comparator에 의해 정의되는 순서를 기준으로 정렬한다.
- 제네릭에 대하여
  - 제네릭을 쓰는 클래스(ArrayList등)의 인스턴스를 만드는 방법    
    (예)new ArrayList<Song>()
  - 제네릭 타입 변수를 선언하고 변수에 값을 대입하는 방법  
    (예)List<Song> songList = new ArrayList<Song>()
  - 제네릭 타입을 인자로 받아들이는 메서드 선언(호출) 방법  
    (예)void foo(List<Song> list)
        x.foo(songList)
    